name: Playwright Tests + Prettier (reviewdog) + test-flow chart

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

jobs:
  test:
    runs-on: ubuntu-latest
    permissions:
      contents: write # Needed for git operations (restore, commit, push) and for Prettier patch if it makes changes
      pull-requests: write # Needed for sticky PR comment

    steps:
    #---------------------------------------------------
    # 0 – Checkout
    #---------------------------------------------------
    - name: Checkout code (PR branch)
      uses: actions/checkout@v3
      with:
        fetch-depth: 0
        # Explicitly checkout the PR's head branch to allow pushing back
        ref: ${{ github.event.pull_request.head.ref }}

    #---------------------------------------------------
    # 1 – reviewdog CLI
    #---------------------------------------------------
    - name: Setup reviewdog
      uses: reviewdog/action-setup@v1
      with: { reviewdog_version: latest }

    #---------------------------------------------------
    # 2 – Prettier → inline review comments
    #---------------------------------------------------
    - name: Prettier style check (reviewdog)
      shell: bash
      env:
        REVIEWDOG_GITHUB_API_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      run: |
        # Use || true to allow subsequent steps even if Prettier finds issues
        npx prettier --write '**/*.{js,ts,tsx,jsx,json,yml,yaml,md}' || true
        git diff -U0 --no-color > prettier.patch || true
        if [ -s prettier.patch ]; then
          cat prettier.patch | reviewdog -f=diff \
                                         -name="prettier" \
                                         -reporter=github-pr-review \
                                         -filter-mode=diff_context \
                                         -level=warning
        else
          echo "No Prettier issues found."
        fi

    # IMPORTANT CHANGE: Moved this step here, immediately after Prettier.
    # This ensures that Prettier's changes are discarded before any
    # artifact generation or other file manipulations you want to keep/commit.
    - name: Discard Prettier changes before Git operations
      run: git restore .

    #---------------------------------------------------
    # 3 – Node & deps
    #---------------------------------------------------
    - name: Set up Node.js
      uses: actions/setup-node@v4
      with: { node-version: 18 }

    - name: Install dependencies
      run: npm install

    #---------------------------------------------------
    # 4 – Install Playwright browsers
    #---------------------------------------------------
    - name: Install Playwright and browsers
      run: npx playwright install --with-deps

    #---------------------------------------------------
    # 5 – Run Playwright tests
    #---------------------------------------------------
    - name: Run Playwright tests
      run: |
        # Create the directory where Playwright should output its results and screenshots
        # The 'mkdir -p' ensures the directory exists before Playwright tries to write to it.
        mkdir -p published-screenshots/html || true
        echo "Running Playwright tests, outputting artifacts to: published-screenshots"
        # Run Playwright and direct its output to 'published-screenshots'
        # Playwright runs headless by default in CI, so no --headless flag is needed here.
        npx playwright test --output=published-screenshots || true

        echo "Contents of published-screenshots after tests:" # Debugging
        ls -laR published-screenshots || true

    # --- START OF NEW STEPS FOR SCREENSHOT PUBLISHING ---

    # Prepare the directory for PR-specific screenshots on GitHub Pages
    - name: Prepare PR Screenshots for GitHub Pages
      if: github.event_name == 'pull_request' # Only for PRs
      run: |
        PR_NUMBER="${{ github.event.pull_request.number }}"
        # Define the directory path relative to the root of the gh-pages branch
        # This will create "pr/<PR_NUMBER>/screenshots" directly on the gh-pages branch
        GH_PAGES_SCREENSHOT_DIR="pr/$PR_NUMBER/screenshots"
        # Create the temp directory on the runner's workspace
        mkdir -p "$GH_PAGES_SCREENSHOT_DIR"

        # Copy the screenshots to the temp directory
        # We target published-screenshots/html/data because that's where Playwright places its hashed screenshot images
        find published-screenshots/html/data -name "*.png" -exec cp -f {} "$GH_PAGES_SCREENSHOT_DIR/" \; || true
        echo "Copied screenshots to $GH_PAGES_SCREENSHOT_DIR/"
        ls -lh "$GH_PAGES_SCREENSHOT_DIR/" # For debugging, shows what was copied

    # Commit and Push PR Screenshots to GH-Pages branch
    - name: Commit and Push PR Screenshots to GitHub Pages
      if: github.event_name == 'pull_request' # Only for PRs
      uses: EndBug/add-and-commit@v9 # Use this action to commit and push changes
      with:
        # IMPORTANT: Push to the gh-pages branch for GitHub Pages hosting
        branch: gh-pages
        # The path to add on the gh-pages branch
        add: 'pr/${{ github.event.pull_request.number }}/screenshots/'
        message: 'Docs: Publish Playwright screenshots for PR #${{ github.event.pull_request.number }} [skip ci]'
        default_author: github_actions # Use GitHub Actions bot as author
        push: true # This will push to the specified branch (gh-pages)
        # Ensure the token has permissions to push to gh-pages
        token: ${{ secrets.GITHUB_TOKEN }}

    # Generate Markdown for screenshots with their public URLs
    - name: Generate Screenshot Markdown for PR Comment
      id: generate_screenshot_markdown
      if: github.event_name == 'pull_request' # Only for PRs
      run: |
        # The base URL needs to be the GitHub Pages URL for your repository.
        # This URL now points to the content on the gh-pages branch.
        GITHUB_PAGES_BASE_URL="https://digitalproductinnovationanddevelopment.github.io/Code-Reviews-of-GUI-Tests/pr/${{ github.event.pull_request.number }}/screenshots/"

        PR_DIR="pr/${{ github.event.pull_request.number }}/screenshots" # Path as it will be on gh-pages, for checking existence

        IMAGE_MARKDOWN=""
        # Check if the target screenshot directory was populated in the local runner workspace
        # We assume if it was copied in 'Prepare PR Screenshots for GitHub Pages', it exists here.
        # This check is primarily for debugging scenarios where no screenshots are generated.
        # The 'ls -1' command is used here to get just the filenames without extra details.
        # It's important to list files from the *original* location or ensure the 'add-and-commit'
        # step provides feedback on what was actually committed if this step fails to find.
        # For simplicity, we'll iterate on what was found in the *original* source if possible,
        # or rely on the `ls -lh "$GH_PAGES_SCREENSHOT_DIR/"` from the prepare step logs.
        # However, to be robust for markdown generation *after* push,
        # we generally need to know what was *expected* to be pushed.
        # A simpler approach for PR comments is to iterate based on the find from the previous step.
        # Let's assume the previous `find` was successful and use its output if needed.
        # For direct generation here, we'll re-find if the directory exists in the original published path.

        # A more robust approach might be to capture the list of image files in a previous step's output
        # and pass it to this step, but for now, re-finding in the original source directory is simpler.
        if [ -d "published-screenshots/html/data" ] && find "published-screenshots/html/data" -maxdepth 1 -name "*.png" -print -quit | grep -q .; then
            for img_file in published-screenshots/html/data/*.png; do
                img_name=$(basename "$img_file")
                img_url="${GITHUB_PAGES_BASE_URL}${img_name}"
                IMAGE_MARKDOWN+="![${img_name}](${img_url})\n\n"
            done
        else
            IMAGE_MARKDOWN+="No screenshots available for this PR.\n\n"
        fi

        echo "pr_screenshots_markdown<<EOF" >> $GITHUB_OUTPUT
        echo "$IMAGE_MARKDOWN" >> $GITHUB_OUTPUT
        echo "EOF" >> $GITHUB_OUTPUT
      shell: bash

    # --- END OF NEW STEPS FOR SCREENSHOT PUBLISHING ---

    #---------------------------------------------------
    # 6 – Upload HTML report
    #---------------------------------------------------
    - name: Upload HTML report
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: playwright-html-report
        # Playwright puts HTML report in html/ subfolder of --output (after playwright.config.js change)
        path: |
          published-screenshots/html/
          published-screenshots/results.json
        if-no-files-found: ignore

    #---------------------------------------------------
    # 7 – Extract test summary
    #---------------------------------------------------
    - name: Extract test summary
      id: summary
      run: |
        REPORT_FILE="published-screenshots/results.json" # Point to correct results.json location
        echo "Attempting to extract summary from: $REPORT_FILE"

        if [ ! -f "$REPORT_FILE" ]; then
          echo "Error: Playwright report file not found at $REPORT_FILE"
          # Set default values if report is missing to prevent later failures
          echo "total=0" >> $GITHUB_OUTPUT
          echo "passed=0" >> "$GITHUB_OUTPUT"
          echo "failed=0" >> "$GITHUB_OUTPUT"
          echo "skipped=0" >> "$GITHUB_OUTPUT"
          echo "duration=0" >> "$GITHUB_OUTPUT"
          echo "passrate=0.00" >> "$GITHUB_OUTPUT"
          exit 0 # Allow workflow to continue even if report is missing
        fi

        # Parse data from the JSON report
        TOTAL=$(jq '.stats.total' "$REPORT_FILE")
        PASSED=$(jq '.stats.expected' "$REPORT_FILE")
        FAILED=$(jq '.stats.failures' "$REPORT_FILE")
        SKIPPED=$(jq '.stats.skipped' "$REPORT_FILE")
        DURATION=$(jq '.stats.duration' "$REPORT_FILE")
        PASS_RATE=$(awk "BEGIN{printf \"%.2f\", ($TOTAL==0)?0:($PASSED/$TOTAL)*100}")

        # Set outputs for subsequent steps
        echo "total=$TOTAL" >> "$GITHUB_OUTPUT"
        echo "passed=$PASSED" >> "$GITHUB_OUTPUT"
        echo "failed=$FAILED" >> "$GITHUB_OUTPUT"
        echo "skipped=$SKIPPED" >> "$GITHUB_OUTPUT"
        echo "duration=$DURATION" >> "$GITHUB_OUTPUT"
        echo "passrate=$PASS_RATE" >> "$GITHUB_OUTPUT"


    #---------------------------------------------------
    # 8 – ESLint (tests only)
    #---------------------------------------------------
    - name: Run ESLint on GUI tests
      shell: bash
      run: |
        # Check if the 'tests' directory exists before running ESLint
        if [ -d "tests" ]; then
          echo "Running ESLint on tests directory."
          # Output ESLint results to a JSON file for easier parsing
          # The '|| true' allows the workflow to continue even if ESLint finds errors
          # Add this mkdir to ensure the directory for eslint-tests.json exists
          mkdir -p reports/eslint || true
          npx eslint "tests/**/*.{js,ts,tsx}" -f json -o reports/eslint/eslint-tests.json || true
          # Debugging: check if file was created and its size
          ls -lh reports/eslint/eslint-tests.json || true
        else
          echo "tests/ directory not found, skipping ESLint."
          # Create an empty JSON file so subsequent steps don't fail gracefully
          mkdir -p reports/eslint || true
          echo "[]" > reports/eslint/eslint-tests.json
        fi

    - name: Upload ESLint report
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: eslint-test-report
        path: reports/eslint/eslint-tests.json
        # Add if-no-files-found to avoid warning if no report is generated (e.g., if ESLint fails early)
        if-no-files-found: ignore

    - name: Read ESLint report (preview)
      id: lint_summary
      run: |
        if [ -f "reports/eslint/eslint-tests.json" ]; then
          echo 'summary<<EOF' >> "$GITHUB_OUTPUT"
          # Pretty print and get the first 20 lines for a summary
          jq '.' reports/eslint/eslint-tests.json | head -n 20 >> "$GITHUB_OUTPUT"
          echo 'EOF' >> "$GITHUB_OUTPUT"
        else
          echo 'summary<<EOF' >> "$GITHUB_OUTPUT"
          echo 'ESLint report not generated or found.' >> "$GITHUB_OUTPUT"
          echo 'EOF' >> "$GITHUB_OUTPUT"
        fi

    #---------------------------------------------------
    # 9 – Extract ESLint summary
    #---------------------------------------------------
    - name: Extract ESLint summary
      id: eslint_summary
      run: |
        REPORT="reports/eslint/eslint-tests.json" # Update path
        if [ ! -f "$REPORT" ]; then
          echo "Error: ESLint report file not found at $REPORT. Cannot extract summary."
          # Set defaults if report is missing
          echo "total_files=0" >> "$GITHUB_OUTPUT"
          echo "errors=0" >> "$GITHUB_OUTPUT"
          echo "warnings=0" >> "$GITHUB_OUTPUT"
          echo "fixable_errors=0" >> "$GITHUB_OUTPUT"
          echo "fixable_warnings=0" >> "$GITHUB_OUTPUT"
          exit 0
        fi

        TOTAL_FILES=$(jq length "$REPORT")
        ERRORS=$(jq '[.[] | .errorCount] | add' "$REPORT")
        WARNINGS=$(jq '[.[] | .warningCount] | add' "$REPORT")
        FIXABLE_ERRORS=$(jq '[.[] | .fixableErrorCount] | add' "$REPORT")
        FIXABLE_WARNINGS=$(jq '[.[] | .fixableWarningCount] | add' "$REPORT")

        echo "total_files=$TOTAL_FILES" >> "$GITHUB_OUTPUT"
        echo "errors=$ERRORS" >> "$GITHUB_OUTPUT"
        echo "warnings=$WARNINGS" >> "$GITHUB_OUTPUT"
        echo "fixable_warnings=$FIXABLE_WARNINGS" >> "$GITHUB_OUTPUT"
        echo "fixable_errors=$FIXABLE_ERRORS" >> "$GITHUB_OUTPUT"


    #---------------------------------------------------
    # 10 – Generate Suite→Spec Mermaid chart (flowchart.png)
    #---------------------------------------------------
    - name: Generate test-flow chart
      shell: bash
      run: |
        # Set locale for 'tr' command to behave predictably across environments
        export LC_ALL=C
        set -e # Exit immediately if a command exits with a non-zero status

        REPORT_FILE="published-screenshots/results.json" # Point to correct results.json location
        echo "Attempting to generate flowchart from: $REPORT_FILE"

        if [ ! -f "$REPORT_FILE" ]; then
          echo "Error: Playwright report file not found at $REPORT_FILE for flowchart generation. Skipping chart."
          exit 0 # Exit this step gracefully if report is missing
        fi

        echo "graph TD" > flowchart.mmd

        # Use jq to parse the JSON and format it for Mermaid, ensuring safe IDs
        jq -r '
          .suites[] as $file |
          ($file.title // "NO_FILE_TITLE") as $fileTitle |
          $file.suites[]? as $suite |
            ($suite.title // "NO_SUITE_TITLE") as $suiteTitle |
            $suite.specs[]? as $spec |
              ($spec.title // "NO_SPEC_TITLE") as $specTitle |
              [$fileTitle, $suiteTitle, $specTitle] | @tsv
        ' "$REPORT_FILE" |
        while IFS=$'\t' read -r fileTitle suiteTitle specTitle; do
          # Sanitize titles to create valid Mermaid IDs (alphanumeric, underscores, limited length)
          fileId=$(echo "$fileTitle" | sed 's/[^a-zA-Z0-9_]/_/g' | sed 's/^_*\|_*$//g' | cut -c 1-50)
          suiteId=$(echo "${fileTitle}_${suiteTitle}" | sed 's/[^a-zA-Z0-9_]/_/g' | sed 's/^_*\|_*$//g' | cut -c 1-50)
          specId=$(echo "${fileTitle}_${suiteTitle}_${specTitle}" | sed 's/[^a-zA-Z0-9_]/_/g' | sed 's/^_*\|_*$//g' | cut -c 1-50)

          # Skip if IDs become empty after sanitization
          if [ -z "$fileId" ] || [ -z "$suiteId" ] || [ -z "$specId" ]; then
            echo "Warning: Skipped a test entry due to invalid/empty IDs after sanitization. Original: File='$fileTitle', Suite='$suiteTitle', Spec='$specTitle'"
            continue
          fi

          # Add nodes and edges to flowchart.mmd, checking for duplicates
          if ! grep -q "^  ${fileId}\[" flowchart.mmd; then
            echo "  ${fileId}[\"${fileTitle}\"]" >> flowchart.mmd
          fi
          if ! grep -q "^  ${suiteId}\[" flowchart.mmd; then
            echo "  ${suiteId}[\"${suiteTitle}\"]" >> flowchart.mmd
            echo "  ${fileId} --> ${suiteId}" >> flowchart.mmd
          fi
          echo "  ${suiteId} --> ${specId}[\"${specTitle}\"]" >> flowchart.mmd
        done

        # Configuration for Puppeteer (used by mermaid-cli)
        printf '{ "args": ["--no-sandbox","--disable-setuid-sandbox"] }\n' > puppeteer.json

        # Run mermaid-cli to generate the flowchart image
        npx -y @mermaid-js/mermaid-cli@10.6.1 \
          -p puppeteer.json \
          -i flowchart.mmd \
          -o flowchart.png || true # Add || true to allow subsequent steps if mermaid-cli fails

        ls -lh flowchart.png || true # List generated file, add || true for robustness


    - name: Show flowchart.mmd for debugging
      run: cat flowchart.mmd || true # Show content for debugging, add || true for robustness

    - name: Upload test-flow chart
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: test-flow-chart
        path: flowchart.png
        if-
